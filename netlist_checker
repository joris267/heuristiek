import itertools
import numpy as np
import data as data
import random


X_SIZE = data.X_SIZE
Y_SIZE = data.Y_SIZE
Z_SIZE = data.Z_SIZE
chips = data.chips
netlist = data.netlist_2
print "original length %i"%(len(netlist))

def findNeighbours(point):
    neighbours = []
    for dimension in range(3):
        for direction in range(-1, 2, 2):
            if point[2] == 7:
                if direction == 1 and dimension == 3:
                    continue
            list_point = list(point)

            list_point[dimension] += direction
            neighbour = tuple(list_point)
            if inGrid(neighbour) and isFree(neighbour):
                neighbours.append(neighbour)
    return neighbours


def inGrid(point):
    return (0 <= point[0] < X_SIZE) and (0 <= point[1] < Y_SIZE) and (0 <= point[2] < Z_SIZE)


def connectionsPerChip(netlist):
    """
    returns a dictionary with the chip as key and the number of connections as value
    """

    chip_to_occurrences = {}

    # list(itertools.chain.from_iterable(netlist)) is quickest way to chain items in a list together in a new list
    chips_in_netlist = list(itertools.chain.from_iterable(netlist))

    # bincount counts occurrences of integers in list. Value is put at the index
    # i.e. np.bincount([0,1,1,4]) => [0,2,0,0,1]
    # http://docs.scipy.org/doc/numpy/reference/generated/numpy.bincount.html
    occurrences = np.bincount(chips_in_netlist)
    for i in range(len(occurrences)):
        chip_to_occurrences[i] = occurrences[i]
    return chip_to_occurrences


def isFree(point):
    """
    For a given point (x,y,z) returns True if Free, else False
    """
    global grid
    for i in point:
        if i < 0:
            return False
    try:
        value = grid[point[0]][point[1]][point[2]]
    # print value
    except:
        # print "point ", point, "lies outside of grid"
        return False
    return value == -1


def checkDouble(netlist):
    doubles = []
    for net1 in netlist:
        reversed_net = (net1[1], net1[0])
        occurces = 0
        for net2 in netlist:
            if net1 == net2 or net2 == reversed_net:
                occurces += 1

        if occurces == 2:
            doubles.append(net1)
        elif occurces > 2:
            print net1, "was found %i times and hass to be removed by hand" %(occurces)

    print "removing doubles: ", doubles
    for net in set(doubles):
        netlist.remove(net)

    return netlist


def checkBeginIsEnd(netlist):
    start_is_end = []
    for net in netlist:
        if net[0] == net[1]:
            start_is_end.append(net)

    print "removing ", start_is_end
    for net in start_is_end:
        netlist.remove(net)

    return netlist

def checkConenctions(netlist):
    connections_dict = connectionsPerChip(netlist)
    chips_in_netlist = set(list(itertools.chain.from_iterable(netlist)))
    for chip in chips_in_netlist:
        if connections_dict[chip] > 5:
            print chip, "has %s connections and some will have to be removed" %(str(connections_dict[chip]))


def createGrid():
    """
    creates an grid filled with True except on the points in chips
    imports chips, X_SIZE, Y_SIZE and Z_SIZE from data
    """
    grid = np.ones(shape=(X_SIZE, Y_SIZE, Z_SIZE), dtype=int)
    grid.fill(-1)
    for chip in chips:
        grid[chip[0]][chip[1]][chip[2]] = -2
    return grid


def setValue(point, value):
    if inGrid(point):
        grid[point[0]][point[1]][point[2]] = value


def checkConnectionDensity(netlist):

    connections_dict = connectionsPerChip(netlist)
    chips_in_netlist = set(list(itertools.chain.from_iterable(netlist)))
    for chip, chip_index in zip(chips_in_netlist, range(len(chips_in_netlist))):
        connections = connections_dict[chip]
        free_neighbours = findNeighbours(chips[chip])
        for _ in range(connections):
            if len(free_neighbours) == 0:
                break
            first_step = random.choice(free_neighbours)
            setValue(first_step, chip_index)
            free_neighbours.remove(first_step)
            connections_dict[chip] -= 1

    unlayable_paths = [(chip, connections_dict[chip]) for chip in connections_dict if connections_dict[chip] > 0]
    print "chips that have unlayable connetions", unlayable_paths


# def checkMaxConnectionDensity(netlist):
#
#     connections_dict = connectionsPerChip(netlist)
#     chips_in_netlist = set(list(itertools.chain.from_iterable(netlist)))
#     for chip, chip_index in zip(chips_in_netlist, range(len(chips_in_netlist))):
#         free_neighbours = findNeighbours(chips[chip])
#         for _ in range(connections):
#             if len(free_neighbours) == 0:
#                 break
#             first_step = random.choice(free_neighbours)
#             setValue(first_step, chip_index)
#             free_neighbours.remove(first_step)
#             connections_dict[chip] -= 1
#
#     unlayable_paths = [(chip, connections_dict[chip]) for chip in connections_dict if connections_dict[chip] > 0]
#     print "chips that have unlayable connetions", unlayable_paths




if __name__ == "__main__":
    grid = createGrid()
    netlist = checkBeginIsEnd(netlist)
    netlist = checkDouble(netlist)
    checkConnectionDensity(netlist)
    checkConenctions(netlist)

    print len(chips)
    print "there are now to few nets, %i new paths will have to be found. Bellow I'll print the number of  \
          connections per chip "%(65 - len(netlist))
    print connectionsPerChip(netlist)
    print len(netlist)